import { writeFile } from 'fs/promises';
import path from 'path';

import type { Lockfile, ResolvedDependencies, TarballResolution } from '@pnpm/lockfile-types';
import { nameVerFromPkgSnapshot, pkgSnapshotToResolution } from '@pnpm/lockfile-utils';

import type { Dependencies as YarnDependencies, Package as YarnPackage, YarnLock } from './types';
import { dedicatedLockfile, parseLockfile, workspaceProjectPaths, packagesWithSpecifiers, versionWithoutPeersSuffix } from '../../pnpm';

export async function convert(lockfileDir: string): Promise<YarnLock> {
  const lock = await parseLockfile(lockfileDir);
  return convertLockfile(lock);
}

export function convertLockfile(lock: Lockfile): YarnLock {
  const packages = packagesWithSpecifiers(lock);

  return Object.fromEntries(packages.map(({ pkg: snapshot, depPath, matchingDependencies }) => {
    const { version } = nameVerFromPkgSnapshot(depPath, snapshot);
    const resolution = pkgSnapshotToResolution(depPath, snapshot, { default: 'https://registry.npmjs.org/' });

    const pkg: YarnPackage = {
      version,
      resolved: (resolution as TarballResolution).tarball,
    };

    const integrity = (resolution as TarballResolution).integrity;
    if (integrity) pkg.integrity = integrity;

    if (snapshot.dependencies) {
      pkg.dependencies = convertDependencies(snapshot.dependencies);
    }

    if (snapshot.optionalDependencies) {
      pkg.optionalDependencies = convertDependencies(snapshot.optionalDependencies)
    }

    const names = new Set(
      matchingDependencies.map(({ name, specifier }) => `"${name}@${specifier}"`)
    );
    if (names.size == 0) {
      throw new Error(`could not find dependency specifiers for package: ${depPath}`)
    }

    return [Array.from(names).join(", "), pkg] as const
  }));
}

// Strip peers suffix from dependency version
function convertDependencies(dependencies: ResolvedDependencies): YarnDependencies {
  return Object.fromEntries(
    Object.entries(dependencies ?? {}).map(([name, version]) => {
      return [name, versionWithoutPeersSuffix(version)];
    })
  );
}

export function serialize(lock: YarnLock): string {
  const preamble = `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n# yarn lockfile v1\n`;
  const packages = Object.entries(lock)
    .map(([path, pkg]) => {
      let acc = `${path}:
  version "${pkg.version}"
  resolved "${pkg.resolved}"
`;

      if (pkg.integrity) {
        acc += `  integrity "${pkg.integrity}"\n`
      }

      acc += dependenciesSection("dependencies", pkg.dependencies);
      acc += dependenciesSection("optionalDependencies", pkg.optionalDependencies);

      return acc;
    })
    .join('\n');

  return `${preamble}\n\n${packages}`;
}

function dependenciesSection(sectionKey: string, dependencies: YarnDependencies | null | undefined): string {
  if (dependencies && Object.keys(dependencies).length) {
    const deps = Object.entries(dependencies)
      .map(([k, v]) => `    "${k}" "${v.replace(/\(.*/, '')}"`)
      .join('\n');
    return `  ${sectionKey}:\n${deps}\n`;
  } else {
    return ""
  }
}

export async function write(lockfileDir: string): Promise<void> {
  await convert(lockfileDir)
    .then(serialize)
    .then((lock) => writeFile(path.join(lockfileDir, 'yarn.lock'), lock));
}

export async function writeRecursive(lockfileDir: string): Promise<void> {
  const packages = await workspaceProjectPaths(lockfileDir);

  // Make and convert lockfiles for workspace packages
  await Promise.all(
    Array.from(packages).map(async (pkgDir) => {
      await dedicatedLockfile(lockfileDir, pkgDir)
        .then(convertLockfile)
        .then(serialize)
        .then((lock) => writeFile(path.join(pkgDir, 'yarn.lock'), lock));
    })
  );

  // and root
  await write(lockfileDir);
}
